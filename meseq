#! /usr/bin/env python3
# coding: utf-8
import sys
import os
import argparse

VERSION = '2.0'

Verbose = 0
GlobalFont = None
GlobalBgcolor = 'white'

def setVerbosity(n):
    global Verbose
    Verbose = n

def log(*args):
    msg = ''
    for arg in args:
        if len(msg) != 0: msg += ' '
        msg += '%s' % (arg)
    print(msg)

def info(*args):
    log('Info:', *args)

def debug(*args):
    if Verbose < 1: return
    log('Debug:', *args)

def error(*args):
    log('Error:', *args)

def setGlobalFont(fontObject):
    global GlobalFont
    GlobalFont = fontObject


def setSourceColor(cairoCtx, colorName):
    if colorName in [ None, 'none' ]:
        cairoCtx.set_source_rgba(0, 0, 0, 0)
    else:
        colorObject = Color(colorName)
        cairoCtx.set_source_rgb(colorObject.red(), colorObject.green(), colorObject.blue())


def nodeid(rowid, colid):
    return "row%d_col%d" % (rowid, colid)


class SequenceDiagram(object):

    def __init__(self, outputfile, matrix, pixWidth, imgFormat, mscInit):

        nActors = len(matrix.rows[-1])

        dot = self.draw(matrix)

        with open('tmp.dot', 'w') as f:
            f.write(dot)

        os.system("dot -T%s < tmp.dot > %s" % (imgFormat, outputfile))


    def draw(self, matrix):

        dot = '''strict digraph {
            splines=line // have strait edges
            fontname="Helvetica,Arial,sans-serif"
            layout=dot
        '''
        # draw nodes and register their given name: nodeid(rowid, colid)
        for rowid in range(len(matrix.rows)):
            row = matrix.rows[rowid]

            # draw invisible horizontal dependencies
            dot += """edge [style=invis,weight=10]\n"""
            horizontal_nodes = []
            for colid in range(len(row)):
                horizontal_nodes.append(nodeid(rowid, colid))
            dot += 'rank=same {' + ' -> '.join(horizontal_nodes) + '}\n'

            for colid in range(len(row)):

                node = row[colid]

                if node is None:
                    # draw an invisible node
                    dot += nodeid(rowid, colid)
                    dot += """ [shape=none,style=invis,label=""]\n"""
                    continue

                node.nodeid = nodeid(rowid, colid) # store the id for the second pass

                if rowid > 0:
                    # establish the life line with the above item
                    if matrix.rows[rowid-1][colid] is None:
                        # draw a line
                        dot += """edge [weight=1000,style=invis]\n"""
                        dot += "%s -> %s\n" % (nodeid(rowid-1, colid), node.nodeid)
                    else:
                        # draw an invisible dependency
                        dot += """edge [weight=1000,arrowhead=none,style=solid]\n"""
                        dot += "%s -> %s\n" % (nodeid(rowid-1, colid), node.nodeid)

                if node.type == NT_TERMINATE:
                    # draw an 'x'
                    dot += node.nodeid
                    dot += """ [shape=none,label="x"]\n"""

                elif node.type in [ NT_ACTOR, NT_BOX ]:
                    # draw a box with label
                    dot += node.nodeid
                    dot += """ [shape=box,label="%s"]\n""" % node.options['label']

                else:
                    # draw a small dot
                    dot += node.nodeid
                    dot += """ [style=invis,shape=circle,width=0.01,fixedsize=true,label=""]\n"""


        # do a second pass for drawing relationships
        for rowid in range(len(matrix.rows)):
            row = matrix.rows[rowid]

            for colid in range(len(row)):
                node = row[colid]
                if node is None: continue

                if node.type == NT_ACTOR and hasattr(node, 'originator'):
                    # draw an edge from the originator to the current node
                    dot += node.originator.nodeid + ' -> ' + node.nodeid
                    dot += """ [label="%s"]\n""" % node.originator.options['label']

                elif node.type == NT_CREATE:
                    # do not draw anything
                    # the arrow and the actor is drawn on the node NT_ACTOR
                    pass

                elif node.type == NT_MSG_SEND:
                    if node.actorSrc == node.actorDest:
                        # message to self not supported
                        pass
                    else:
                        dot += node.nodeid + ' -> ' + node.arrival.nodeid
                        dot += """ [style=solid,weight=0,arrowhead=normal,label="%s"]\n""" % node.options['label']


                # if node.type == NT_MSG_LOST
                #     TODO get nodeid of the destination
                # if node.type == NT_MSG_RETURN
                #     TODO feasible ?
                # if node.type == NT_BIDIRECTIONAL
                #     TODO feasible ?
                # 

        dot += '}'
        return dot


# Node types
NT_ACTOR     = 'actor'
NT_MSG_SEND  = 'send-message'
NT_MSG_RECV  = 'recv-message'
NT_MSG_LOST  = 'lost-message'
NT_MSG_RETURN = 'return-message'
NT_CREATE    = 'create'
NT_BOX       = 'box'
NT_BIDIRECTIONAL = "bidirectional"
NT_TERMINATE = 'terminate'
NT_REF_NOTE  = 'ref_note'
NT_COLON     = 'colon'
NT_LIFELINE  = 'lifeline'

class Node:
    def __init__(self, type):
        self.type = type
        self.actorSrc = None   # for message-related nodes, id of the actor sending a message
        self.actorDest = None  # for message-related nodes, id of the actor receiving a message
        self.options = {'label': ''}
        self.id = None # used for 'goto'
        self.isTall = False # indicate if the picture is vertically tall (box, etc.)

        if self.type == NT_ACTOR: self.lifelineOwner = self
        else: self.lifelineOwner = None

        if self.type in [ NT_ACTOR, NT_BOX, NT_BIDIRECTIONAL ]: self.isTall = True

    def __repr__(self):
        return '<%s:%s->%s(%s)>' % (self.type, self.actorSrc, self.actorDest, self.options['label'])

def readInput(file):
    pass

def die(msg):
    sys.stderr.write('Error: ' + msg + '\n')
    sys.exit(1)

def lexerConsolidateLines(data):
    """Concatenate lines ending with a backslash and the line afterwards.
    """
    lines = data.splitlines()
    outLines = []
    currentLine = ''

    for line in lines:

        currentLine += line

        if len(line) and line[-1] == '\\':
            # remove the \
            currentLine = currentLine[:-1]
            # and let the next line be concatenated (on next oteration)
        else:
            outLines.append(currentLine)
            currentLine = ''

    if len(line) and line[-1] == '\\':
        die('Invalid last char \'\\\' on last line')

    return outLines

def parseSectionName(tokens):
    """Parse the section name."""
    if len(tokens) != 3: die('Malformed section declaration (length): \'%s\'' % tokens)
    if tokens[0] != '[' or tokens[2] != ']': die('Malformed section declaration: \'%s\'' % line)
    return tokens[1]

ReservedTokens = [ '=', ':', '[', ']' ]

def isIdentifierChar(c):
    return c == '_' or c.isalnum()
    
def lexerParseDollar(line, i):
    """Parse a line after a dollar.
    @param i
        The offset of the character following the dollar.
        
    @return
        The value of the env variable, and the offset after the consumed sequence.
    """
    if len(line) == i: die("Malformed dollar expression (too short): '%s'" % line)
    
    inCurlyBracket = False
    if line[i] == '{':
        inCurlyBracket = True
        i += 1
    
    envkey = ''
    while i < len(line) and isIdentifierChar(line[i]):
        envkey += line[i]
        i += 1
    
    if inCurlyBracket:
        if i >= len(line): die("Missing closing '}' (short line): '%s'" % line)
        if line[i] != '}': die("Missing closing '}': '%s'" % line)
        i += 1
        
    if envkey in os.environ: envvalue = os.environ[envkey]
    else: envvalue = ''
    
    return envvalue, i
        

def lexerParse(line):
    """
    Return the list of the tokens of the line.
    
    Basic tokens:
        token ::= (identifier | string | reserved)

        identifier ::=  (letter|"_") (letter | digit | "_")*
        letter     ::=  lowercase | uppercase
        lowercase  ::=  "a"..."z"
        uppercase  ::=  "A"..."Z"
        digit      ::=  "0"..."9"

        string            ::=  (simplestring | quotedstring) (simplestring | quotedstring)*
        quotedstring      ::=  '"' (quotedstringchar | escapeseq | dollarvar)* '"'
        quotedstringchar  ::=  <any character except "\", newline, '"'>
        escapeseq         ::=  "\" <any ASCII character>
        simplestring      ::=  simplestringitem simplestringitem*
        simplestringitem  ::=  (simplestringchar | escapeseq | dollarvar)
        simplestringchar  ::=  <any character except " ", "\", newline, '"'>
        dollarvar         ::=  "$" (identifier | "{" identifier "}")

    Escape Sequences:
        \n      \\      \"    \$

    Reserved:
        =    :    [    ]

    """
    # states
    ST_READY = 0
    ST_IN_TOKEN = 1 # simple string
    ST_IN_DQUOTE = 2 # double quoted string
    ST_ESCAPED = 3 # indicate if a \ is just before the char
    ST_DOLLAR = 4

    state = ST_READY
    tokens = []
    currentToken = None
    envvar = None
    i = 0
    while i < len(line):
        c = line[i]

        if state == ST_READY:
            assert currentToken == None
            if c == '#': break # rest of the line is a comment, ignore it
            if c.isspace():
                i += 1
                continue
            if c in ReservedTokens:
                tokens.append(c)
                i += 1
                continue
                
            currentToken = '' # the following cases shall initiate a token
            if c == '"':
                state = ST_IN_DQUOTE
            elif c == '\\':
                savedState = ST_IN_TOKEN # after the escape sequence, the state will be ST_IN_TOKEN
                state = ST_ESCAPED
            elif c == '$':
                savedState = ST_IN_TOKEN # after the dollar sequence, the state will be ST_IN_TOKEN
                state = ST_DOLLAR
            else:
                state = ST_IN_TOKEN
                currentToken = c

        elif state == ST_DOLLAR:
            value, i = lexerParseDollar(line, i)
            currentToken += value
            state = savedState
            continue # i already incremented
                
        elif state == ST_ESCAPED:
            if c == 'n': currentToken += '\n'
            else: currentToken += c
            state = savedState

        elif state == ST_IN_TOKEN:

            if c == '\\':
                savedState = state
                state = ST_ESCAPED

            elif c in ReservedTokens:
                tokens.append(currentToken)
                tokens.append(c)
                state = ST_READY
                currentToken = None

            elif c.isspace():
                tokens.append(currentToken)
                state = ST_READY
                currentToken = None

            elif c == '$':
                savedState = state
                state = ST_DOLLAR
                
            elif c == '"': state = ST_IN_DQUOTE
            else: currentToken += c

        elif state == ST_IN_DQUOTE:
            if c == '\\':
                savedState = state
                state = ST_ESCAPED
            elif c == '"': state = ST_IN_TOKEN
            elif c == '$':
                savedState = state
                state = ST_DOLLAR
            else: currentToken += c
            
        else:
            die("Invalid state '%s'" % state)
            
        i += 1
           
    # append last token
    if currentToken is not None: tokens.append(currentToken)
    
    return tokens

def tokenParseActor(tokens):
    """Expected tokens:
    actorid [options ...]

    Options:
        label=... ('label=' optional)
        color=...
        bgcolor=...
    """
    if len(tokens) == 0:
        die('Invalid actor specification: %s' % tokens)

    actorid = tokens[0]
    if actorid == '': return None # this is a hidden actor

    options = tokenParseKeyEqualValue(tokens[1:])

    if not 'label' in options: options['label'] = actorid

    node = Node(NT_ACTOR)
    node.actorSrc = actorid
    node.options.update(options)
    return node


def tokenParseKeyEqualValue(line):
    token1 = None
    token2 = None
    options = {}
    originalLine = line[:]
    while len(line) > 0:
        tok = line.pop(0)
        if tok == '=':

            if token2 is None:
                die('Invalid = in line: %s' % originalLine)

            if token1 is not None:
                options['label'] = token1

            token1 = token2
            token2 = tok

        elif token1 is None and token2 is None:
            token2 = tok

        elif token2 == '=':
            if token1 is None:
                die('Invalid a=b wihout a, in line: %s' % originalLine)
            key = token1
            value = tok
            options[key] = value
            token1 = None
            token2 = None
        elif token1 is None and token2 is not None:
            token1 = token2
            token2 = tok
        else:
            die('unexpected error in line: %s' % originalLine)

    if token2 is not None:
        options['label'] = token2

    return options

def tokenParseScenarioLine(line):
    """Return a Node()."""

    if line[0] == ':':
        node = Node(NT_COLON)
        if len(line) == 1:
            pass # anonymous label, used for inserting a blank line
        elif len(line) == 2:
            # named label
            node.id = line[1]
        else:
            die('Invalid goto-label, too many tokens (%d)' % len(line))

        return node

    elif len(line) >= 2 and line[1] == '+':
        node = Node(NT_TERMINATE)
        node.actorSrc = line[0]
        # parse the options
        options = tokenParseKeyEqualValue(line[2:])
        node.options.update(options)
        return node

    elif len(line) < 3:
        die('Invalid scenario line: %s' % line)

    # message 
    src = line[0]
    dest = line[2]
    if line[1] == '->': node = Node(NT_MSG_SEND)
    elif line[1] == '<-':
        node = Node(NT_MSG_SEND)
        src, dest = dest, src # reverse src and dest
    elif line[1] == '-x': node = Node(NT_MSG_LOST)
    elif line[1] == 'x-':
        node = Node(NT_MSG_LOST)
        src, dest = dest, src
    elif line[1] == '-*': node = Node(NT_CREATE)
    elif line[1] == '<->': node = Node(NT_BIDIRECTIONAL)
    elif line[1] == '-<': node = Node(NT_MSG_RETURN)
    elif line[1] == '>-':
        node = Node(NT_MSG_RETURN)
        src, dest = dest, src
    elif line[1] == '-box': node = Node(NT_BOX)
    else:
        die('Invalid message line: %s' % line)

    node.actorSrc = src
    if node.type != NT_BOX:
        node.actorDest = dest
    else:
        node.options['label'] = dest
    # parse the options
    options = tokenParseKeyEqualValue(line[3:])
    node.options.update(options)

    return node


    
class MsqLine:
    pass

INCLUDE_FILE_OK        = 1
INCLUDE_FILE_NOT_FOUND = 2

class MsqFile:
    def __init__(self):
        self.sections = {}
        self.currentSection = None
        self.includedFiles = []
        self.includedSections = []
        self.currentPath = []


    def getWorkingDir(self):
        return self.currentPath[0]

    def pushWorkingDir(self, path):
        self.currentPath.insert(0, path)

    def popWorkingDir(self):
        self.currentPath.pop(0)

    def load(self, filename):
        try:
            f = open(filename)
            data = f.read()
            f.close()
        except:
            die('Cannot load file: %s' % filename)
        return data
        
    def preprocess(self, filename):
        """Load a meseq file, and preprocess:
            - consolidate multi-lines lines
            - resolve include files
        """
        # if relative path, be relative to current file
        if os.path.isabs(filename):
            path = filename
        elif len(self.currentPath) == 0:
            path = filename
        else:
            path = os.path.join(self.getWorkingDir(), filename)

        self.pushWorkingDir(os.path.dirname(path))

        # detect cyclic includes
        abspath = os.path.abspath(path)
        if abspath in self.includedFiles:
            die('Cyclic include of file: %s' % (abspath))
        self.includedFiles.append(abspath)

        data = self.load(path)
        lines = lexerConsolidateLines(data)
        self.tokenizeLines(lines)

        self.includedFiles.remove(abspath)
        self.popWorkingDir()

    def include(self, token):
        """If token is an existing file, include it.
        Else keep it unchanged.
        """
        if os.path.exists(os.path.join(self.currentPath[0], token)):
            self.preprocess(token)
            return INCLUDE_FILE_OK
        else:
            return INCLUDE_FILE_NOT_FOUND

    def tokenizeLines(self, lines):
        for line in lines:
            tokens = lexerParse(line)
            if len(tokens) == 0: continue
            elif tokens[0] == '-include':
                if len(tokens) != 2: die('Invalid include (%s)' % (tokens) )
                r = self.include(tokens[1])
                if r == INCLUDE_FILE_NOT_FOUND:
                    self.sections[self.currentSection].append(tokens)

            elif tokens[0] == '[':
                self.currentSection = parseSectionName(tokens)
                if self.currentSection in self.sections:
                    die('Section redeclared: ' + self.currentSection)
                self.sections[self.currentSection] = []

            else:
                self.sections[self.currentSection].append(tokens)

        return tokens

    def preprocessSection(self, section):
        # detect cyclic includes
        if section in self.includedSections:
            die('Cyclic include of section: %s' % (section))
        self.includedSections.append(section)

        if not section in self.sections:
            die('%s: No such file or section, thus cannot include' % (section) )

        n = len(self.sections[section])
        i = 0
        while i < n:
            line = self.sections[section][i]
            if line[0] == '-include':
                if len(line) != 2:
                    die('Invalid syntax for -include: %s' % (line) )
                # do the include
                includedSection = line[1]
                self.preprocessSection(includedSection)
                for includedLine in self.sections[includedSection]:
                    self.sections[section].insert(i, includedLine)
                    i += 1
                    n += 1

                # remove the '-include' line
                x = self.sections[section].pop(i)
                # no need ito increment i, as the '-include' line has been removed
                n -= 1

            else: i += 1

        self.includedSections.remove(section)

    def preprocessIncludedSections(self):
        """Process remaining '-include', and resolve inclusion of sections.
        """
        # Only preprocess the 2 sections that are really used
        # ie: the 2 entry points 'init' and 'scenario'
        self.preprocessSection('init')
        self.preprocessSection('scenario')
                
class Font:
    def __init__(self):
        self.sizeRatio = 100 # percent
        self.family = 'Georgia'
        self.style = ''

    def getSize(self, scale):
        return self.sizeRatio / 100.0 * 10 * scale

class MscInit:
    def __init__(self):
        self.initialActors = []
        self.font = Font()
        self.border = None

def parseMscSizeRatio(tokens):
    try:
        s = tokens[0]
        if s[-1] != '%':
            error('Invalid font-size specification: must be a percentage')
            return 100
        return int(s[:-1])
    except:
        error('Invalid font-size specification: %s (must be a percentage)' % tokens)
        return 100

def pasrseMscInit(linesOfTokens):

    mscInit = MscInit()
    for line in linesOfTokens:
            
        if line[0] == 'actor':
            actor = tokenParseActor(line[1:])
            mscInit.initialActors.append(actor)

        elif line[0] == 'font-size':
            mscInit.font.sizeRatio = parseMscSizeRatio(line[1:])

        elif line[0] == 'font-style':
            mscInit.font.style = line[1]

        elif line[0] == 'font-family':
            mscInit.font.family = line[1]

        elif line[0] == 'bgcolor':
            c = line[1]
            if c == 'none': setGlobalBgcolor(None)
            else: setGlobalBgcolor(c)

        elif line[0] == 'border':
            mscInit.border = line[1]
            if mscInit.border == 'none': mscInit.border = None

        else:
            die('Invalid declaration in init: %s' % line)

    return mscInit

def mscParse(filename):
    """Parse the input msq file and extract the tokens.
    """
    msq = MsqFile()
    msq.preprocess(filename)
    msq.preprocessIncludedSections()

    mscInit = pasrseMscInit(msq.sections['init'])

    if len(mscInit.initialActors) == 0:
        die('No initial actor')

    setGlobalFont(mscInit.font)

    # parse section 'scenario'
    lifeline = []
    for line in msq.sections['scenario']:
        lifeline.append(tokenParseScenarioLine(line))

    return mscInit, lifeline

class GraphRow(list):
    def __init__(self, nColumns, halfsize = False):
        if halfsize: self.height = 0.5
        else: self.height = 1

        for c in range(0, nColumns):
            self.append(None)

class SequenceGraph:
    def __init__(self):
        self.labels = {}
        self.rows = []
        self.activeActors = []
        self.pendingMessages = []
        self.gotoLabels = {}

    def setGotoLabel(self, id):
        self.gotoLabels[id] = len(self.rows) - 1 # index of the last row (== current row)

    def addActiveActor(self, actor):

        for i in range(len(self.activeActors)):
            if self.activeActors[i] is None:
                self.activeActors[i] = actor
                return

        self.activeActors.append(actor)

    def hasActor(self, actorid):
        for a in self.activeActors:
            if a is not None and a.actorSrc == actorid:
                return True
        return False

    def getActiveActor(self, actorid):
        for a in self.activeActors:
            if a is not None and a.actorSrc == actorid:
                return a
        return None

    def removeActor(self, actorId):
        for i in range(len(self.activeActors)):
            if self.activeActors[i] is not None:
                if self.activeActors[i].actorSrc == actorId:
                    self.activeActors[i] = None
                    return

    def getNewRow(self, halfsize):
        nColumns = len(self.activeActors)
        return GraphRow(nColumns, halfsize)

    def getIndex(self, actorid):
        for i in range(len(self.activeActors)):
            if self.activeActors[i] is not None:
                if self.activeActors[i].actorSrc == actorid:
                    return i
        return None

    def init(self, initialActors):
        self.activeActors = initialActors
        row = GraphRow(0, False)
        for a in self.activeActors:
            row.append(a)
        self.rows = [ row ]

    def getCurrentRow(self):
        """Return a reference to the last row."""
        return self.rows[-1]

    def updateLifeline(self):
        """Update last row with lifelines."""
        row = self.rows[-1]
        for i in range(len(self.activeActors)):
            if self.activeActors[i] is not None:
                if row[i] is None:
                    row[i] = Node(NT_LIFELINE)
                    row[i].lifelineOwner = self.activeActors[i]

    def insertBlankRow(self):
        self.addNewRow()

    def addNewRow(self, halfsize = False):
        self.updateLifeline()
        self.rows.append(self.getNewRow(halfsize))
        currentRow = self.getCurrentRow()
        return currentRow

    def place2(self, node1, node2, tall = False):
        """Place 2 connected nodes on the same row.

        Args:
            tall: True if node1 or node2 is vertically tall,
                  that implies that it should not touch any tall
                  node of the row above.
        """
        currentRow = self.getCurrentRow()
        index1 = self.getIndex(node1.actorSrc)
        index2 = self.getIndex(node2.actorSrc)

        if index1 is None:
            die('place2: Cannot place on unknown actor: %s' % node1.actorSrc)

        if index2 is None:
            die('place2: Cannot place on unknown actor: %s' % node2.actorSrc)

        #if index1 == len(currentRow) or index2 == len(currentRow):
        #    # case of a newly created actor; the row is therefore busy
        #    currentRow.append(None)

        needNewRow = False
        needSeparationRow = False

        first = min(index1, index2)
        second = max(index1, index2)
        for i in range(first, second+1):
            if currentRow[i] is not None:
                # this row is busy, need a new row
                needNewRow = True
                break

        if tall and len(self.rows) >= 1:
            previousRow = self.rows[-1]
            for i in range(first, second+1):
                if len(previousRow) > i:
                    nodeAbove = previousRow[i]
                    if nodeAbove is not None and nodeAbove.isTall:
                        needSeparationRow = True
                        break

        if needSeparationRow:
            currentRow = self.addNewRow(True)

        if needNewRow:
            currentRow = self.addNewRow(False)

        currentRow[index1] = node1
        currentRow[index2] = node2
        node1.x = index1
        node2.x = index2
        node1.y = node2.y = len(self.rows) - 1


    def place(self, node, tall = False):
        currentRow = self.getCurrentRow()
        index = self.getIndex(node.actorSrc)
        if index is None:
            die('Cannot place on unknown actor: %s' % node.actorSrc)

        if index == len(currentRow):
            # case of a newly create actor
            currentRow.append(None)

        needNewRow = False
        needSeparationRow = False

        if currentRow[index] is not None:
            # this row is busy, take the next one
            needNewRow = True

        if tall:
            # check if the row just above is also tall (box, etc.)
            if len(self.rows) >= 1 and len(self.rows[-1]) > index:
                nodeAbove = self.rows[-1][index]
                if nodeAbove is not None and nodeAbove.isTall:
                    needSeparationRow = True

        if needSeparationRow:
            currentRow = self.addNewRow(True)

        if needNewRow:
            currentRow = self.addNewRow(False)

        currentRow[index] = node
        node.x = index
        node.y = len(self.rows) - 1
        
    def queue(self, node):
        self.pendingMessages.append(node)

    def placePending(self, flushAll = False):
        i = 0
        while i < len(self.pendingMessages):
            node = self.pendingMessages[i]

            if 'goto' in node.options:
                gotoId = node.options['goto']
                # in the past, so the node can be placed
                if gotoId in self.gotoLabels: gotoId = None

            else:
                gotoId = None

            if flushAll or gotoId is None:
                # place the node immediately
                self.place(node)
                self.pendingMessages.pop(i)
            else:
                i += 1 # keep it for later

            
def computeGraph(initialActors, data):
    graph = SequenceGraph()
    # init first row, with initial actors

        
    graph.init(initialActors)

    # go through the lifeline
    for nod in data:

        if hasattr(nod, 'actorSrc'):
            nod.lifelineOwner = graph.getActiveActor(nod.actorSrc)
        else: nod.lifelineOwner = None

        if nod.type in [ NT_MSG_SEND, NT_MSG_LOST ]:

            graph.place(nod)

            # Do the recv part
            if nod.type == NT_MSG_SEND:
                recvNode = Node(NT_MSG_RECV)
                recvNode.actorSrc = nod.actorDest
                recvNode.lifelineOwner = graph.getActiveActor(nod.actorDest)

                if 'goto' in nod.options:
                    recvNode.options['goto'] = nod.options['goto']
                nod.arrival = recvNode
                graph.queue(recvNode)

        elif nod.type in [ NT_BIDIRECTIONAL, NT_MSG_RETURN ]:
            otherNode = Node(NT_MSG_RECV)
            otherNode.actorSrc = nod.actorDest
            otherNode.lifelineOwner = graph.getActiveActor(nod.actorDest)
            nod.arrival = otherNode
            graph.place2(nod, otherNode, tall=True)

        elif nod.type == NT_CREATE:
            # TODO check if the arrow may conflict with other message on the row

            if graph.hasActor(nod.actorDest):
                die('Cannot create already existing actor: %s' % nod.actorDest)

            graph.place(nod)

            # place new actor
            newActor = Node(NT_ACTOR)
            newActor.actorSrc = nod.actorDest
            newActor.options['label'] = newActor.actorSrc # possibliy oevrwritten by 'actor_label'
            newActor.originator = nod
            for key in nod.options:
                # Options starting by 'actor_' are intended for the new actor
                if key[0:6] == 'actor_':
                    newActor.options[key[6:]] = nod.options[key]

            nod.arrival = newActor
            graph.addActiveActor(newActor)

            graph.place(newActor)
            
        elif nod.type == NT_BOX:
            # insert a row if previous node is a NT_BOX or NT_ACTOR
            # so that they do not touch each other
            graph.place(nod, tall=True)

        elif nod.type == NT_TERMINATE:
            graph.place(nod)
            graph.removeActor(nod.actorSrc)

        elif nod.type == NT_COLON:
            if nod.id is None:
                # insert a row
                graph.insertBlankRow()
            else:
                graph.setGotoLabel(nod.id)

        # Look if some pending messages can be received
        graph.placePending()

    # flush pending messages
    graph.placePending(flushAll=True)
    graph.updateLifeline()

    return graph
            
        
def main():
    """Process a msq file and generate an image of the message sequence diagram.
    """

    parser = argparse.ArgumentParser(description=main.__doc__, prog='meseq')
    parser.add_argument('file', nargs=1, help='msq file')
    parser.add_argument('-V', '--version', help='print version and exit', action='version', version='%(prog)s ' + VERSION)
    parser.add_argument('-v', '--verbose', action='store_true', help='be more verbose')
    parser.add_argument('-f', '--format', choices=['png', 'svg'], help='format of the generated image (default: png)', default='png')
    parser.add_argument('-o', '--output', help='name of the generated image')
    parser.add_argument('-w', '--width', help='width in pixel of the generated image (default: 600)', default='600')

    args = parser.parse_args()

    if args.verbose: setVerbosity(1)

    filename = args.file[0]
    mscInit, data = mscParse(filename)
    debug('initialActors=', mscInit.initialActors)
    debug('data=', data)
    matrix = computeGraph(mscInit.initialActors, data)
    debug("matrix=", matrix.rows)

    imgFormat = args.format

    if args.output is None:
        imagefile = filename + '.' + imgFormat
    else:
        imagefile = args.output

    width = int(args.width)
    SequenceDiagram(imagefile, matrix, width, imgFormat, mscInit)
    info('Generated image: %s' % (imagefile) )

if __name__ == '__main__':
    main()
